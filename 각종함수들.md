# euc-kr 바이트 계산
```js
function calcByteEuckr(str) {
  return str
    .split('') 
    .map(s => s.charCodeAt(0))	// 유니코드 값으로 변환
    .reduce((prev, c) => (prev + ((c === 10) ? 2 : ((c >> 7) ? 2 : 1))), 0); // c 값이 0~127사이에 있으면 1바이트
}
```

<br>

# euc-kr 최대 바이트만큼 문자열 자르기
```js
function getLimitedByteEuckrText(str, maxByte) {
  if (!str) return;
  let b;
  for (b = i = 0; (c = str.charCodeAt(i)); ) {
    b += (c === 10) ? 2 : ((c >> 7) ? 2 : 1);

    if (maxByte && b > maxByte) {
      break;
    }

    i++;
  }
  return maxByte ? str.substring(0, i) : b;
}
```

# 특수문자 지우기
commonMixins.js - removeEmojis(string)
```js
removeEmojis(string) {
  if (!string) return;
  let regex =
    /(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0025-\u0039]\ufe0f?\u20e3|\u3299|\u321C|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff]|[\uFFFC-\uFFFD]|[\u2600-\u2604]|[\u2607-\u260D]|[\u260F-\u2659]|\u2662|\u2666|\u2668|[\u2670-\u26FF])/g;
  return string.replace(regex, '');
}
```

# 전화번호 검색
```js
function searchText(keyword) {
	let rows = [{
    "name": "한민주",
    "mobileNo": "010-1111-1111",
    "rowKey": 0,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "한민주",
    "mobileNo": "010-2222-2222",
    "rowKey": 1,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "한민주",
    "mobileNo": "010-3333-3333",
    "rowKey": 3,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "한민주",
    "mobileNo": "010-4444-4444",
    "rowKey": 2,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "한민주",
    "mobileNo": "010-5555-5555",
    "rowKey": 4,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }];
  
  let searchedRows = rows.filter(ele => ele.mobileNo.includes(keyword));  // 검색된 목록
  let restRows = rows.filter(item => !rows.includes(item) || !searchedRows.includes(item));  // 나머지 목록
  let result = searchedRows.concat(restRows.sort((a, b) => a.rowKey - b.rowKey)); // 두 목록 합친 결과
}
```

<br>

# 전체 배열 내에 중복 값이 있는지
```js
let rows = [{
    "name": "한민주",
    "mobileNo": "010-1111-1111",
    "rowKey": 0,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "한민주",
    "mobileNo": "010-1111-1111",
    "rowKey": 1,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "한민주",
    "mobileNo": "010-3333-3333",
    "rowKey": 3,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "한민주",
    "mobileNo": "010-4444-4444",
    "rowKey": 2,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "한민주",
    "mobileNo": "010-5555-5555",
    "rowKey": 4,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }];

// 전화번호만 추출
let arr = rows.map(x => x.mobileNo);

// CASE01 : Set() 사용
function toFindDuplicates1(arry) {
    const uniqueElements = new Set(arry);	// 1, 2, 3, 4, 5
    const filteredElements = arry.filter(item => {
        if (uniqueElements.has(item)) {
            uniqueElements.delete(item);
        } else {
            return item;
        }
    });

    return [...new Set(filteredElements)]
}
console.log(toFindDuplicates1(arr));

// CASE02 : indexOf() 사용
const toFindDuplicates2 = x => x.filter((item, index) => arr.indexOf(item) !== index)
console.log(toFindDuplicates2(arr));
```


## 언제?
파일 업로드로 추가했을 때 전체 탐색
주소록으로 추가했을 때 전체 탐색

그냥 전체 중에 중복 비교 or 입력한 만큼과 원래 있던 리스트 비교

방금 입력한 값이 이미 있는지(중복으로 입력된 건지) ? 이렇게 하면 중복 값 입력했을 때 나머지 중복 하나는 안 나옴

# 배열에서 값 하나라도 찾으면 종료
```js
let data = [
  {name: "jack", age: 20},
  {name: "marry", age: 25},
  {name: "kevin", age: 10}
];

let result = data.some(x => {
  return x.age >= 20;
}); // true
```


# 핸드폰 번호 검사
```js
function isPhoneNumber(phoneNumber) {
	// var regPhoneNumber = /^(01[016789]{1}|02|0[3-9]{1}[0-9]{1})([0-9]{3,4})([0-9]{4})$/
	let regPhoneNumber = /^(01[016789]{1})-?([0-9]{3,4})-?([0-9]{4})$/;

	if (regPhoneNumber.test(phoneNumber)) {
		return true;
	}

	return false;
}
```

# 한글, 영문만 입력 가능(영문은 띄어쓰기 가능)
```js
function isHangleEnglishSpace(str) {
	let value1 = /^[가-힣\s]+$/;
	let value2 = /^[a-zA-Z\s]+$/;
	let value3 = /^[가-힣a-zA-Z\s]+$/;
	if (value1.test(str) || value2.test(str) || value3.test(str)) {
		return true;
	}

	return false;
}
```

# 변수 길이 체크 => 바이트로 체크해야 할 듯
```js
function isVarLengthCheck(str) {
	if (str === null || str === undefined || str === '') str = '';
	if (str.length < 50) {
		return true;
	}
	return false;
}
```

# 수신 불가 번호 체크
```js
let list = [{
    mobileNo: "01043259852",
    denyDate: "2022-05-05"
  }, {
    mobileNo: "01011112222",
    denyDate: "2022-05-12"
  }];

function isDenyMobileNumber(input) {
  let result = list.some(x => x.mobileNo === input);
  return result;
}

console.log(isDenyMobileNumber('01043259852'));
```

# 금지어 포함 여부
```js
let str = '넌 바보야';
let list = ["바보", "멍청이"];

function isDenyStr(input) {
  let result = list.some(x => input.includes(x));
  return result;
}

console.log(isDenyStr(str));
```

# 이미지 추가
이미지 가변은 버튼을 컴포넌트로 떼고 template: `` 안에 내용 작성
플러스 버튼은 만들어놓고 3개면 숨기고 아니면 보이고
```html
<div id='it_list'>
	<button @click='add()'>목록 추가</button>
	<ul>
		<it-component v-for="it in its">
		</it-component>
	</ul>
</div>
출처: https://mine-it-record.tistory.com/350 [나만의 기록들:티스토리]
```
```js
Vue.component('it-component',{
	template: '<li v-on:click="mine()">it list</li>',
	methods:{
		mine : function(){
			console.log("record");
		}
	}
});

new Vue({
	el: '#it_list',
	data: {
		its : []
	},
	methods: {
		add : function(){
			this.its.push('it');
		}
	}
});
```

# 엑셀 파일 업로드
```html
<input onchange="loadFile(this)" type="file" accept=".csv, .txt" />
```

```js
<div class="uxfile">
  <label class="uxlabel">
    <input
      type="file"
      name=""
      class="uxinp"
      @change="readCsvFile"
      accept=".csv,.txt"
    />
    <p class="btn-custum upload">CSV 업로드</p>
  </label>
</div>

readCsvFile(event) {
  return new Promise((resolve, reject) => {
    this.downloadLoading = true;
    setTimeout(() => {
      resolve('ok');
    }, 500);
  }).then(res => {
    this.readCsvFiles(event);
  });
},

readCsvFiles(event) {
  try {
    let validExts = ['.csv', '.txt'];											// 허용 확장자
    let file = event.target.files[0];											// 파일
    let fileName = file.name;															// 파일명
    let fileExt = this.getExtensionOfFilename(fileName);	// 파일 확장자

    if (!validExts.includes(fileExt)) {
      this.$alert('잘못된 파일입니다. CSV, TXT 파일만 업로드 가능합니다.', '안내', { dangerouslyUseHTMLString: true });
    }
    
    console.log(`파일명: ${fileName}`);

    const reader = new FileReader();
    reader.onload = e => {
      console.log(`시작: ${new Date()}`)
      let data = e.target.result;
      let lines = data.split('\n').map(x => x.replace(/\s/,''));
      // let headers = lines[0].split(",");
      let headers = ['name', 'mobileNo', 'alrimTalkVar1', 'alrimTalkVar2', 'alrimTalkVar3'];
      let result = [];
      for (let i = 1; i < lines.length; i++) {
          let obj = {};
          let currentline = lines[i].split(",");

          for (let j=0; j<headers.length; j++) {
            obj.num = `${i}, ${j}`;
            obj[headers[j]] = currentline[j];
          }
          result.push(obj);
      }
      console.log(result);
      console.log(`끝: ${new Date()}`)
      this.excelUploadData = result;
      this.downloadLoading = false;
      this.excelUploadPopupFlag = true;
    };
    reader.readAsText(file);
  } catch (error) {
    console.log(error)
  } finally {
    this.downloadLoading = false;
  }
},
```
https://webdoli.tistory.com/393

# 전화번호 like 검색
: https://stackoverflow.com/questions/65289444/javascript-two-array-in-object-deduplication
```js
const rowDatas = [{
    "name": "가",
    "mobileNo": "010-1111-1111",
    "rowKey": 0,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "나",
    "mobileNo": "010-1111-1111",
    "rowKey": 1,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "라",
    "mobileNo": "010-3333-3333",
    "rowKey": 3,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "다",
    "mobileNo": "010-4444-4444",
    "rowKey": 2,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }, {
    "name": "마",
    "mobileNo": "010-5555-5555",
    "rowKey": 4,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값"
  }];

// 검색, 데이터 필터링
const searchedDatas = rowDatas.filter(x => x.mobileNo.replaceAll('-', '').includes('0101'));
const notSearchedDatas = rowDatas.filter(row => {
  return !searchedDatas.some(item => row.rowKey === item.rowKey)
});

// 오름차순 정렬 (나중에 num으로 변경)
searchedDatas.sort((a, b) => a.rowKey < b.rowKey ? -1 : 1);
notSearchedDatas.sort((a, b) => a.rowKey < b.rowKey ? -1 : 1);

// 검색된 목록 + 나머지 목록
const resultDatas = [...searchedDatas, ...notSearchedDatas];
console.log(resultDatas)
```

# 입력오류 우선 정렬
맨 처음 데이터 세팅할 때부터 각 항목의 유효성 체크 여부를 가지고 있어야 함
이름 체크 여부, 전화번호 체크 여부, 변수1 체크 여부, 변수2 체크 여부, 변수3 체크 여부, (이 데이터를 다 포함하는)행 체크 여부
```js
// 입력오류 우선 정렬은 데이터 포커스 아웃 시마다 체크하는 건 순서만 바꾸어주면 됨 = CASE 1
// 데이터 포커스 아웃 시마다 체크할 수 없으면 입력오류 정렬 시 재검사하여 순서를 바꾸어주어야 함 = CASE 2

// CASE 1
const rowDatas = [{
    "name": "가",
    "mobileNo": "010-1111-1111",
    "rowKey": 0,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값",
    "isValidRow": true
  }, {
    "name": "나",
    "mobileNo": "010-1111-1111",
    "rowKey": 1,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값",
    "isValidRow": true
  }, {
    "name": "라",
    "mobileNo": "010-3333-3333",
    "rowKey": 3,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값",
    "isValidRow": false
  }, {
    "name": "다",
    "mobileNo": "010-4444-4444",
    "rowKey": 2,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값",
    "isValidRow": false
  }, {
    "name": "마",
    "mobileNo": "010-5555-5555",
    "rowKey": 4,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값",
    "isValidRow": true
  }];
 
// 유효한 데이터와 아닌 데이터 필터링 및 정렬
const invalidDatas = rowDatas.filter(x => !x.isValidRow).sort((a, b) => a.rowKey < b.rowKey ? -1 : 1);
const validDatas = rowDatas.filter(x => x.isValidRow).sort((a, b) => a.rowKey < b.rowKey ? -1 : 1);

// 유효한 데이터 + 유효하지 않은 데이터
const resultDatas = [...invalidDatas, ...validDatas];
```

# 본문 입력 시 변수 작성 파악 / 본문에서 변수 지울 때 변수 삭제
맨 처음엔 어떻게..?
columns 데이터 바뀌었을 때만 바꾸기
## eval
```js
<textarea id="input_textarea" onkeyup="checkMainText(this)"></textarea>
<textarea id="result"></textarea>


function checkMainText(obj) {
	// this.본문 = 변환된 본문
  
  // 입력된 값 = v-bind된 변수
  let acceptVariablesText = ['#{이름}', '#{변수1}', '#{변수2}', '#{변수3}'];
  let acceptVariables = ['nameColumn', 'var1Column', 'var2Column', 'var3Column'];
  let value = obj.value;
  
  // watched로 컬럼 true/false 감시해서 바뀌면 columns 바꿔주기
  // 변수 클릭 시에 textarea에 넣어주고 trigger('keydown')
  let variableUsed = {
  	nameColumn: false,
    mobileNoColumn: true,
    var1Column: false,
    var2Column: false,
    var3Column: false
  }
  
  acceptVariablesText.forEach(function(item, index) {
  	if (value.includes(item)) {
    	variableUsed[acceptVariables[index]] = true;
    } else {
    	variableUsed[acceptVariables[index]] = false;
    }
  });
  
  setColumns(variableUsed);
}

function setColumns(variableUsed) {
	let nameColumn = {title: '이름', name: 'name'};
  let mobileNoColumn = {title: '전화번호', name: 'mobileNo'};
	let var1Column = {title: '변수1', name: 'var1'};
  let var2Column = {title: '변수2', name: 'var2'};
	let var3Column = {title: '변수3', name: 'var3'};

	let columns = [];
	for (const [key, value] of Object.entries(variableUsed)) {
  	if (value) {
    	columns.push(eval(key));
    }
  }
  
  document.getElementById('result').value = columns.map(x => x.title).toString();
}
```


# 본문 입력 처리할 것들
```js
<textarea id="input_textarea" onkeyup="checkContent(this)"></textarea>
<textarea id="result"></textarea>


function checkContent(obj) {
  // 1. byte 체크
  calcByteEuckrFormat(obj.value);
  
  // 2. 입력 불가 문자 체크(특수문자 및 금지어)
  deleteForbiddenWords(obj.value);
  
  // 3. 변수 입력 체크
  detectVariableInput(obj.value);
}

function getVariableType() {
   const acceptVariables = {
     nameColumn: '#{이름}',
    var1Column: '#{변수1}',
    var2Column: '#{변수2}',
    var3Column: '#{변수3}'
  }
  
  return acceptVariables;
}

function calcByteEuckrFormat(text) {
   const acceptVariables = getVariableType();   // 변수 종류
  const bytePerVariable = 40;                              // 변수 당 바이트 수
  
  // #{변수} 바이트 계산 (변수 포함 개수 * 변수 기준 바이트)
  let variableCount = 0;
  for (const [key, value] of Object.entries(acceptVariables)) {
     variableCount += text.split(value).length - 1;   // 변수가 포함된 개수
    text = text.replaceAll(value, '');
  }
  let variableByte = variableCount * bytePerVariable;
  
  // #{변수} 제외 본문 바이트 게산
  let byte = text
    .split('') 
    .map(s => s.charCodeAt(0))   // 유니코드 값으로 변환
    .reduce((prev, c) => (prev + ((c === 10) ? 2 : ((c >> 7) ? 2 : 1))), 0);
   
  return byte + variableByte;
}

function deleteForbiddenWords(text) {
  if (!text) return;
  let regex =
    /(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0025-\u0039]\ufe0f?\u20e3|\u3299|\u321C|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff]|[\uFFFC-\uFFFD]|[\u2600-\u2604]|[\u2607-\u260D]|[\u260F-\u2659]|\u2662|\u2666|\u2668|[\u2670-\u26FF])/g;
    
  return text.replace(regex, '');
}

function detectVariableInput(text) {
  const acceptVariables = getVariableType();
  const columnList = {
     nameColumn : {title: '이름', name: 'name'},
    mobileNoColumn: {title: '전화번호', name: 'mobileNo'},
    var1Column: {title: '변수1', name: 'var1'},
    var2Column: {title: '변수2', name: 'var2'},
    var3Column: {title: '변수3', name: 'var3'}
  }
  
  // 변수 클릭 시에 textarea에 넣어주고 trigger('keydown')
  let columns = [columnList.mobileNoColumn];
  for (const [key, value] of Object.entries(acceptVariables)) {
     if (text.includes(value))   columns.push(columnList[key]);
  }
  
  // 이전 컬럼 리스트랑 지금 구한 컬럼 리스트랑 다를 경우 다시 로드
  let temp1 = [columnList.nameColumn, columnList.mobileNoColumn];
  let temp2 = [columnList.nameColumn, columnList.mobileNoColumn, columnList.var1Column];
  let isChanged = false;
  if (JSON.stringify(temp1) !== JSON.stringify(temp2))   isChanged = true;
	
  document.getElementById('result').value = columns.map(x => x.title).toString();
}
```

# 컬럼 전체가 비어있는지 체크
```js
const rowDatas = [{
    "name": "가",
    "mobileNo": "010-1111-1111",
    "rowKey": 0,
    "alrimTalkVar1": "",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값",
    "isValidRow": true
  }, {
    "name": "나",
    "mobileNo": "010-1111-1111",
    "rowKey": 1,
    "alrimTalkVar1": "",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값",
    "isValidRow": true
  }, {
    "name": "라",
    "mobileNo": "010-3333-3333",
    "rowKey": 3,
    "alrimTalkVar1": "변수1값",
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값",
    "isValidRow": false
  }, {
    "name": "다",
    "mobileNo": "010-4444-4444",
    "rowKey": 2,
    "alrimTalkVar1": null,
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값",
    "isValidRow": false
  }, {
    "name": "마",
    "mobileNo": "010-5555-5555",
    "rowKey": 4,
    "alrimTalkVar2": "변수2값",
    "alrimTalkVar3": "변수3값",
    "isValidRow": true
  }];
  
let result = rowDatas.some(x => x.alrimTalkVar1);	// 알림톡1 변수에 값이 하나라도 있으면 true
console.log(result);	// true or false

// let result = rowDatas.reduce((acc, curr) => curr.alrimTalkVar1 ? acc + 1 : acc, 0);
// console.log(result);	// 결과가 포함된 개수
```

# 즉시발송/예약발송
즉시발송일 때는 광고여부, 시간 체크
1) 발송가능한 시간일 경우 발송
2) 발송불가능한 시간일 경우 알럿
예약발송일 때는 광고여부, 설정한 시간 체크 (다른 쪽에는 8시부터 20시까지만 지정 가능)

survey.js
```js
//주문 가능 시간대 확인 (08 ~ 20)
export function checkPossibleOrderTime(data) {
  return request({
    url: "/v2/survey/order/possibleOrderTime",
    method: "post",
    headers: { "Content-Type": "application/json" },
    data
  });
}
```

GorderInfoNormal.vue
```js
// 즉시발송 주문 가능시간 체크
async possibleOrderTime() {

  const { code, message, result } = await checkPossibleOrderTime({});
  console.log(`possibleOrderTime- code:${code}, message:${message}`);
  if (code === 'SUC0000') {
    return true;
  } else
  if (code === 'ERRSV003') {
    await AlarmMsg.showMsg(`주문가능한 시간이 아닙니다. (08시 ~ 21시)`);
  } else {
    await AlarmMsg.showMsg(`오류가 발생하였습니다.`);
  }

  return false;
}
```

엑셀 업로드할 때 데이터 다 읽어서 본문에 안 쓰였는데 값 있으면 알림 메시지 바꿔주기


엑셀 업로드 / 주소록 등록 시에 데이터는 올림
-> 이 때 본문에 없으면 안내 문구

컬럼을 보이고 숨기고는 본문 기준

변수가 비어있는 건 상관없음
마지막에 '전체가 비어있을 경우'만 alert 띄우기


문자발송에서 필요한 API 내역
1. 고객 등급 혜택
2. 하단 고정 영역 발송 가능 건수, 문자 발송 가격
3. 발신번호 목록
디폴트 설정은 발신번호 목록 중 첫 번째 값
4. 발신번호 추가, 인증
휴대전화번호/유선번호 인증
5. 광고 문자 발송 가능 시간 체크
기존에는 [/v2/survey/order/possibleOrderTime] API 사용하고 있으나 시간 동일한지 확인 필요
6. 인증코드
7. 주소록 가져오기 전체 목록
8. 테스트 발송
9. 발송 처리(문자 내용, 수신자 체크, 시간 체크, 이미지, 변수 매핑 등 작업)
10. 문자 발송 요청 완료 정보