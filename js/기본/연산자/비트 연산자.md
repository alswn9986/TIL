## 비트 연산자
### **&**
비트의 논리곱을 하는 연산자
- a와 b의 이진수를 한 자리씩 비트 & 연산을 한다.
- & 연산은 두 비트가 모두 참(1)일 경우에만 1, 나머지 경우에는 0이다.
```js
let a = 5, b = 3; // 101 & 011
console.log(a & b); // 1
```

### **|**
비트의 논리합을 하는 연산자
- a와 b의 이진수를 한 자리씩 비트 | 연산을 한다.
- | 연산은 두 비트가 모두 거짓(0)일 때만 0, 나머지 경우에는 1이다.
```js
let a = 5, b = 3; // 101 | 011
console.log(a | b); // 7
```

### **^**
비트의 베타적 논리합을 하는 연산자
- a와 b의 이진수를 한 자리씩 비트 ^ 연산을 한다.
- ^ 연산은 두 비트가 같을 때 0, 다를 때 1을 반환한다.
- 같은 값을 두 번 연산하면 0이 되고, 또 한 번 더하면 그 값이 그대로 나온다.
```js
let a = 5, b = 3; // 101 ^ 011
console.log(a ^ b); // 6
```

### **~**
비트의 부정 연산을 하는 연산자
- 현재 값을 이진수로 변환한 뒤에 0을 1로, 1을 0으로 변환하는 연산을 한다.
```js
console.log(~5);  // -5
```

### **<<**
왼쪽으로 시프트(shift) 연산하는 연산자
- 왼쪽으로 비트를 움직이는 연산을 한다.
- a << b = a * 2^b
```js
let a = 5, b = 3;
// 101을 3번 왼쪽으로 시프트
// 1) 1010
// 2) 10100
// 3) 101000 => 40
console.log(a << b); // 40
```

### **>>**
오른쪽으로 시프트(shift) 연산하는 연산자
- 오른쪽으로 비트를 움직이는 연산을 한다.
- 비트의 위치가 최대값 또는 최소값의 위치 이상으로 시프트할 경우 자동으로 버려진다.
- 비트 연산이므로 일반적으로 숫자를 곱하거나 나누는 것보다 속도가 빠르다.
- a >> b = a / 2^b
```js
let a = 5, b = 2;
// 101을 2번 오른쪽으로 시프트
// 1) 10
// 2) 1 => 1
console.log(a << b); // 1
```

