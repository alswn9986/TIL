## SOLID 원칙
- 함수와 데이터 구조를 클래스로 배치하는 방법, 이들 클래스를 서로 결합하는 방법이다.
- 여기서 클래스는 단순히 함수와 데이터를 결합한 집합을 가리킨다.

### 목적
중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 목적이 있다.
- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용할 수 있는 컴포넌트의 기반이 된다.

> **중간 수준이란?**   
> - 프로그래머가 모듈 수준에서 작업할 때 적용할 수 있다는 의미이다.
> - 코드 수준보다는 조금 상위에서 적용된다.
> - 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다.

<br />

## SRP(Single Responsibility Principle): 단일 책임 원칙
```하나의 모듈은 하나의 액터에 대해서만 책임져야 한다.```
- 액터: 시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자의 집단
- 모듈: 소스 파일, 함수와 데이터 구조로 구성된 응집된 집합

> **모듈이 단 하나의 일을 해야 한다?**
> - 모듈이 단 하나의 일만 해야한다는 것은 단일 책임 원칙이 아니다.
> - 이 원칙은 커다란 함수를 작은 함수들로 리팩터링하는 더 저수준에서 사용된다.

### 단일 책임 원칙을 위반하는 사례
#### 1. 우발적 중복
급여 애플리케이션의 Employ 클래스가 있다. 이 클래스는 3가지 메서드를 가진다.
- calculatePay(): 회계팀에서 CFO 보고를 위해 사용
- reportHours(): 인사팀에서 COO 보고를 위해 사용
- save(): DBA가 CTO 보고를 위해 사용

이 3개의 메서드를 Employ라는 단일 클래스에 배치하여 세 액터가 결합되었다. 한 팀에서 결정한 조치에 따라 다른 팀에도 영향을 줄 수 있다.

#### 2. 병합
많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우 변경 사항이 충돌하여 병합이 발생한다.

### 해결책
메서드를 각기 다른 클래스로 이동시킨다.
1. 데이터와 메서드를 분리하는 방식
2. 퍼사드 패턴을 사용하는 방식

#### 퍼사드(Facade) 패턴
- 클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴인 구조 패턴에 속한다.
- 복잡한 시스템이나 서브 시스템의 간략한 인터페이스를 제공하여 시스템의 복잡성을 감소시키는 패턴이다.
- 시스템 내의 다양한 구성 요소를 캡슐화하는데 사용된다.
- 시스템의 복잡한 부분을 캡슐화하고, 간단한 인터페이스를 제공하는 역할을 한다.
- 시스템의 다른 부분과 결합도가 낮아져 시스템의 특정 부분을 변경하더라도 전체 시스템에 미치는 영향이 적어진다.
- 그 외 구조 패턴: Adapter Pattern, Bridge Pattern, Composite Pattern, Decorator Pattern, Flyweight Pattern, Proxy Pattern

<br />

## OCP(Open-Closed Principle): 개방-폐쇄 원칙
```소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.```
- 소프트웨어 개체의 행위는 확장할 수 있어야 한다.
- 이 때 개체를 변경해서는 안된다.

### 책임 분리
- 시스템을 컴포넌트 단위로 나눈다.
- 서로 다른 목적으로 변경되는 요소를 적절하게 분리한다.(단일 책임 원칙)
- 요소 사이의 의존성을 체계화한다.(의존성 역전 원칙)

### 의존성 계층 구조(컴포넌트 계층 구조 조직화)
- 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라 기능을 분리한다.
- 분리한 기능을 컴포넌트의 계층 구조로 조직화한다.
- 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.
- Database, Controller, Presenter, View에서 발생한 어떤 변경도 Interactor에 영향을 주지 않는다.
- Interactor는 애플리케이션에서 가장 높은 수준의 정책인 업무 규칙을 포함한다.
- Interactor > Controller > Presenter > View

<br />

## LSP(Liskov Substitution Principle): 리스코프 치환 원칙
```부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있어야 한다.```
- 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고한다.

### 직사각형과 정사각형
- 직사각형 객체를 사용하여 넓이를 구하는 것과 정사각형 객체를 사용하여 넓이를 구하는 동작이 다르다.
- 직사각형은 정사각형의 규칙을 완전히 따를 수 없다.(상속 관계가 성립되기 어렵다.)
- 사각형 객체를 구현하고 정사각형, 직사각형이 이를 상속 받으면 리스코프 치환 원칙을 준수한다.

<br />

## ISP(Interface Segregation Principle): 인터페이스 분리 원칙
```객체는 자신이 호출하지 않는 메소드에 의존하지 않아야 한다.```
- 구현할 객체에게 무의미한 구현을 방지하고 반드시 필요한 메서드만 상속, 구현한다.
- 상속할 객체의 규모가 너무 크다면 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다.
- 필요 이상으로 많은 것을 포함하는 모듈에 의존하는 것은 재컴파일과 재배포를 강제한다.
- 언어(정적 타입 언어/동적 타입 언어)에 따라서 또는 아키텍처에 따라서도 발견될 수 있는 문제이다.

<br />

## DIP(Dependency Inversion Principle): 의존성 역전 원칙
```구체화에 의존하지 말고 추상화에 의존해야 한다.```
- 고수준 모듈은 저수준 모듈의 구현에 의존하면 안된다.
- 대신 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
- 저수준 클래스는 빈번하게 변경되고, 새로 추가될 때마다 고수준 클래스가 영향을 받으므로 의존 관계를 역전시켜야 한다.

### 안정된 추상화
- 변동성이 큰 구체 클래스를 참조하지 마라.
- 변동성이 큰 구체 클래스로부터 파생하지 마라.
- 구체 함수를 오버라이드 하지 마라.(추상 함수로 선언하고 구현체들에서 각 용도에 맞게 구현해라.)