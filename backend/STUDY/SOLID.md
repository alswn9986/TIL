## SOLID 원칙
- 함수와 데이터 구조를 클래스로 배치하는 방법, 이들 클래스를 서로 결합하는 방법이다.
- 여기서 클래스는 단순히 함수와 데이터를 결합한 집합을 가리킨다.

### 목적
중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 목적이 있다.
- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용할 수 있는 컴포넌트의 기반이 된다.

> **중간 수준이란?**   
> - 프로그래머가 모듈 수준에서 작업할 때 적용할 수 있다는 의미이다.
> - 코드 수준보다는 조금 상위에서 적용된다.
> - 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다.

<br />

## SRP(Single Responsibility Principle): 단일 책임 원칙
```하나의 모듈은 하나의 액터에 대해서만 책임져야 한다.```
- 액터: 시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자의 집단
- 모듈: 소스 파일, 함수와 데이터 구조로 구성된 응집된 집합

> **모듈이 단 하나의 일을 해야 한다?**
> - 모듈이 단 하나의 일만 해야한다는 것은 단일 책임 원칙이 아니다.
> - 이 원칙은 커다란 함수를 작은 함수들로 리팩터링하는 더 저수준에서 사용된다.

### 단일 책임 원칙을 위반하는 사례
#### 1. 우발적 중복
급여 애플리케이션의 Employ 클래스가 있다. 이 클래스는 3가지 메서드를 가진다.
- calculatePay(): 회계팀에서 CFO 보고를 위해 사용
- reportHours(): 인사팀에서 COO 보고를 위해 사용
- save(): DBA가 CTO 보고를 위해 사용

이 3개의 메서드를 Employ라는 단일 클래스에 배치하여 세 액터가 결합되었다. 한 팀에서 결정한 조치에 따라 다른 팀에도 영향을 줄 수 있다.

#### 2. 병합
많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우 변경 사항이 충돌하여 병합이 발생한다.

### 해결책
메서드를 각기 다른 클래스로 이동시킨다.
1. 데이터와 메서드를 분리하는 방식
2. 퍼사드 패턴을 사용하는 방식

#### 퍼사드(Facade) 패턴
- 클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴인 구조 패턴에 속한다.
- 복잡한 시스템이나 서브 시스템의 간략한 인터페이스를 제공하여 시스템의 복잡성을 감소시키는 패턴이다.
- 시스템 내의 다양한 구성 요소를 캡슐화하는데 사용된다.
- 시스템의 복잡한 부분을 캡슐화하고, 간단한 인터페이스를 제공하는 역할을 한다.
- 시스템의 다른 부분과 결합도가 낮아져 시스템의 특정 부분을 변경하더라도 전체 시스템에 미치는 영향이 적어진다.
- 그 외 구조 패턴: Adapter Pattern, Bridge Pattern, Composite Pattern, Decorator Pattern, Flyweight Pattern, Proxy Pattern

<br />

### OCP(Open-Closed Principle): 개방-폐쇄 원칙
```소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.```



### LSP: 리스코프 치환 원칙
Liskov Substitution Principle
### ISP: 인터페이스 분리 원칙
Interface Segregation Principle
### DIP: 의존성 역전 원칙
Dependency Inversion Principle
