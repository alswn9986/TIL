## HTTP Cache
HTTP 응답을 저장해두고 동일한 HTTP 요청이 시도되면 저장해둔 HTTP 응답을 재활용하는 것이다.
- 브라우저가 시도하는 모든 HTTP 요청은 먼저 브라우저 캐시로 라우팅된다.
- 요청을 수행하는데 사용할 수 있는 유효한 캐시가 있는지 먼저 확인한다.
- 유효한 캐시가 있으면 이 캐시를 읽어서 불필요한 전송으로 발생하는 네트워크 대기시간, 데이터 비용을 상쇄한다.

<br />

### HTTP Cache 이점
- 불필요한 데이터 전송을 줄여 네트워킹 비용을 줄인다.
- 거리로 인한 지연시간을 줄여 웹 페이지를 빨리 불러올 수 있다.
- 서버에 대한 요청을 줄여 서버의 부하를 줄일 수 있다.

> **RTT(Round Trip Time, 왕복 시간)**   
> 인터넷 상에서 송신지부터 목적지까지 패킷이 왕복하는데 걸리는 시간을 의미한다.   
> 유무선 통신인지, 근거리인지 원거리인지, 트래픽 양, 혼잡도 등이 RTT에 영향을 미친다.

<br />

### HTTP Cache 종류
HTTP 응답을 저장해 두는 저장소에 따라 사설 캐시와 지역 캐시로 나뉜다.
최초의 HTTP 요청은 서버에게 전송되어 HTTP 응답을 받아오게 되고, 이를 캐시에 저장해두면 다음에 동일한 HTTP 요청이 시도될 때는 서버에 요청을 다시 보내지 않고 저장되어 있는 HTTP 응답을 재활용한다.
- 사설 캐시(Private Cache)
- 공유 캐시(Shared Cache)
- 게이트웨이 캐시, CDN, 리버스 프록시 캐시 등

#### 사설 캐시(Private Cache)
- 한 사용자에 의해서만 재활용될 수 있는 것들이 저장된다.
- 지역 캐시(Local Cache)라고도 부른다.
- 대표적인 사설 캐시로는 브라우저 캐시가 있다.
- 브라우저 캐시는 기본적으로 사용자가 HTTP 요청을 통해 다운로드한 모든 문서들을 저장하고 있고, 이렇게 저장된 문서들은 뒤로가기나 앞으로가기, 페이지 소스 보기 등에 재활용된다.
- 크롬 브라우저를 사용하면 `C:\Users\사용자명\AppData\Local\Google\Chrome\User Data\Default\Cache`에 저장된다.

#### 공유 캐시(Shared Cache)
- 여러 사용자들에 의해 재활용될 수 있는 것들이 저장된다.
- 대표적인 공유 캐시로는 프록시 캐시가 있다.
- ISP 혹은 회사 측에서 로컬 네트워크인 인프라의 일부로 구축해둔 웹 프록시가 이러한 역할을 담당할 수 있다.
- 사설 캐시는 캐싱을 위해 모든 클라이언트가 한 번씩은 실제 리소스를 접근해야 하지만, 공유 캐시는 서버와 클라이언트 가운데 프록시 등을 통해 캐시를 한다.
- 10만명이 접속한다고 해도 실제 리소스는 1번만 접근되고 나머지는 캐시에서 바로 처리하고 반환한다.

<br />

### HTTP Cache 엔트리
HTTP 캐시에 저장되는 데이터 묶음 하나하나를 캐시 엔트리라고 한다.
- 각 캐시 엔트리를 구분하는 기준은 캐시 키이다.
- 기본적인 캐시 키는 HTTP 요청의 메소드와 URI의 조합으로 결정된다.
- 메소드와 URI가 동일한 하나의 HTTP 요청은 하나의 캐시 엔트리에 대응한다.

<br />

### HTTP Cache 동작 과정
1. 요청 받기와 파싱(Receiving & Parsing)
    - 네트워크로부터 도착한 요청 메시지를 읽고 파싱하여 URL와 헤더들을 추출한다.
1. 캐시 검색(Lookup)
   - 요청에 대응하는 로컬 복사본이 있는지 검사한다.
   - 사본이 없다면 서버에서 데이터를 받아와 복사본을 로컬에 저장한다.
   - 사본이 있다면 다음 단계를 진행한다.
2. 신선도 검사(Freshness check)
   - 캐시가 만료기간이 경과하지 않고 유효한지 검사한다.
3. 응답 생성(Response creation)
   - 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
   - 캐시는 클라이언트에 맞게 헤더를 수정해야 하는 책임이 있다.
   - 캐시는 신선도 정보(Cache-Control, Age, Expires 등)를 삽입한다.
   - Date 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시를 표현하는 것이므로 조정하면 안된다.
4. 발송(Sending)
   - 캐시는 네트워크를 통해 응답을 클라이언트에 돌려준다.
5. 로깅(Logging)
   - 로그파일에 트랜잭션에 대해 서술한 로그를 남긴다.

<br />

### HTTP Cache 적중과 실패
#### Cache Hit
캐시에 요청이 도착했을 때 그에 대응하는 사본이 있으면 이를 이용해 요청을 처리한다.
#### Cache Miss
대응하는 사본이 없으면 origin 서버로 요청이 전달된다.
#### 재확인(Revalidations)
캐시가 적중되어도 origin 서버의 콘텐츠는 변경될 수 있기 때문에 캐시에 담긴 사본이 여전히 최신인지 서버를 통해 확인해야 한다.
- 클라이언트가 캐시에 사본을 요청했는데, 그 사본이 확인이 필요할 정도로 오래된 경우에 실시한다.
- 효과적인 확인을 위해 HTTP는 서버로부터 전체 데이터 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 확인하기 위해 작은 재검사 요청을 보낸다.
- 재확인 적중(Revalidate hit)   
  - 서버의 문서가 변경되지 않았다면 서버는 클라이언트에 `HTTP 304 Not Modified` 응답을 보낸다.
- 재확인 실패(Revalidate miss)   
  - 서버 객체가 캐시된 사본과 다르면 서버는 콘텐츠 전체와 함께 `HTTP 200 OK` 응답을 클라이언트로 보낸다.
- 객체 삭제(Object deleted)   
  - 요청한 콘텐츠가 서버에서 삭제되었다면 서버는 `HTTP 404 Not Found` 응답을 돌려보내며 캐시는 저장된 사본을 삭제한다. 

<br />

### Cache 관련 헤더
#### Expired
- HTTP/1.0+ 에서는 만료기간을 명시하기 위해 절대시간을 사용했다.

#### Cache-Control
HTTP/1.1 로 넘어오면서 만료시간을 명시하기 위한 새로운 헤더가 추가되었다. 캐시 조작과 관련된 다양한 일을 진행한다.
- max-age   
  - 해당 HTTP 메시지가 생성된 Date 헤더를 기준으로 상대적인 시간을 구해 캐시 만료를 표시
- no-store   
  - 캐시는 클라이언트 요청 혹은 서버 응답에 관해 어떤 것도 저장하지 않음
- no-cache   
  - 클라이언트의 요청에 대해 캐시를 사용하지 않고 항상 서버에 재검증을 요청
- private/public   
  - 사설 캐시를 사용할지, 공유 캐시를 사용할지 지정

#### Etag
- 브라우저가 만료된 캐시 응답을 찾을 경우 작은 토큰 하나를 서버로 보내 파일이 변경되었는지 확인
- 만약 서버가 같은 토큰을 리턴하면 파일이 변경되지 않았다는 의미

<br />

## 참고자료
- 캐시 동작 프로세스
  - https://sabarada.tistory.com/143
  - https://thisblogfor.me/web/http/cache/
- 캐시 종류
  - https://it-eldorado.tistory.com/142